\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}

\usepackage{listings}
\usepackage{color}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
 
\lstset{style=mystyle}

\usepackage{upgreek}

\usepackage{amsmath}

\usepackage{graphicx}
\graphicspath{ {imgs/} }

\usepackage{enumitem}

\usepackage{listings}

\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\usepackage{color}
 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
 
\lstset{style=mystyle}

\usepackage{dsfont}

\usepackage{hyperref}

\usepackage[utf8]{inputenc}

\usepackage{mathtools}

\usepackage{textcomp}

\usepackage[english]{babel}

\usepackage{tikz}

\usepackage{tcolorbox}

\usepackage{amsthm,amssymb}

\setlength{\parindent}{0cm}

\renewcommand\qedsymbol{$\blacksquare$}

\usepackage{fancyhdr}
 
\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{Principles of Programming Languages -- Winter 2018}
\fancyhead[RE,LO]{Joshua Concon}
\fancyfoot[CE,CO]{\leftmark}
\fancyfoot[LE,RO]{\thepage}


\begin{document}

\title{CSCC24: Principles of Programming Languages\\ Notes}
\date{University of Toronto Scarborough -- Winter 2018}
\author{Joshua Concon}
\maketitle
This course is taught by Dr. Albert Yu Cheong Lai. If you find any problems in these notes, feel free to contact me at conconjoshua@gmail.com.

\tableofcontents

\pagebreak

\section{Thursday, January 11, 2017}

The purpose of this course is to see the trade-offs between various features in programming languages. This course exists because different programming languages have different features, for example, Java has both class-based OOP and auto-garbage collection while C has neither, but C has union types that Java doesn't have. This means rewriting code into a different language isn't necessarily easy. There may be large semantic differences

\subsection{The Root Cause of this Course}

A guy named "John Backus" gave a lecture for the acceptance for the Turing Award in 1977. He addressed the question, "Can programming be liberated from the von Neumann style?"\\
\\
Languages then had been only superficial enhancements to the CPU writing 1 word onto memory at a time i.e:

\begin{lstlisting}
	s := s + a[i]
\end{lstlisting}

Backus proposed a new direction for programming languages:
\begin{itemize}
    \item Higher order functions that work on aggregates (a whole list, an array, a dictionary, etc...)
    \item Combining forms, for example, function composition ($g \circ f$)
    \item Reasoning by algebra, for example, the associative law for a function
    \item If you need a state, use coarse-grained state transitions rather than changing only one word at a time. (So passing an old state into a stateless function that does a lot and returns an answer and a new state.)
\end{itemize}

\subsubsection{Higher-order Functions on Aggregates}

Note that the notation to apply a function to several parameters is:
\\(Haskell)
\begin{lstlisting}[language=Haskell]
    f x y z
\end{lstlisting}
(Scheme:)
\begin{lstlisting}
    (f x y z)
\end{lstlisting}

So in Haskell:
\begin{lstlisting}[language=Haskell]
    fmap f [x0, x1, ...]
\end{lstlisting}

will compute

\begin{lstlisting}[language=Haskell]
    [f x0, f x1, ...]
\end{lstlisting}

And

\begin{lstlisting}[language=Haskell]
    fmap abs [3,-1,4]
\end{lstlisting}

Computes

\begin{lstlisting}[language=Haskell]
    [3,-1,4]
\end{lstlisting}

And 

\begin{lstlisting}[language=Haskell]
    folder (+) 0 [3,1,4]
\end{lstlisting}

Computes

\begin{lstlisting}[language=Haskell]
    3+(1+(4+0))
\end{lstlisting}

Note 2 points:
\begin{itemize}
    \item "on aggregates" means to work on a whole list at once (such as an array or some "container")
    \item "Higher-order functions" means that some parameters are functions, so different combinations makes the language more customizable.
\end{itemize}

Java and MATLAB have the former but lack the latter.

\subsubsection{Combining Forms}

An obvious example is function composition $(g \circ f)$.

In Haskell, this is:
\begin{lstlisting}[language=Haskell]
    g . f
\end{lstlisting}

And in Racket (Scheme) this is:
\begin{lstlisting}
    compose g f
\end{lstlisting}

For example, the following code computes the 1-norm of your vector.

\begin{lstlisting}[language=Haskell]
    foldr (+) 0 . fmap abs
\end{lstlisting}

There are other combining forms. There is another example in Haskell.

\begin{lstlisting}[language=Haskell]
    (f &&& g) x = (f x, g x)
\end{lstlisting}

The point is that you can combine functions to perform compound tasks, and this type of language is not about shorter code (although it has that side effect), but about working with building blocks.

\subsubsection{Example Topic: Evaluation Order}

You can define your own logical "and" in Scheme

\begin{lstlisting}
    (define (my-and b c) (if b c #f))
    (my-and #f (list-ref '(#t #f #t) 10))
\end{lstlisting}

The second line fails in Scheme, but if typed in the Haskell version, succeeds.\\
\\
In most languages, parameters are evaluated before passed into the bodies of functions. In Haskell however, parameters are passed as is. Because of this, in Haskell, many short circuiting operators and control constructs are user-definable, and therefore, very customizable.

\subsubsection{Example Topic: Scheme Macros}

Scheme offers a macro system for user-defined constructs:

\begin{lstlisting}
    (define-syntax-rule (my-and b c) (if b c #f))
\end{lstlisting}

Now if we run the following code, it succeeds.

\begin{lstlisting}
    (my-and #f (list-ref '(#t #f #t) 10))
\end{lstlisting}

The explanation for this is that this is a macro expansion in Scheme, so the parameters are copy-pasted into the macros. This means that there is a downside, for example:

\begin{lstlisting}
    (define-syntax-rule (double x) (+ x x))
    (double (* 3 4))
\end{lstlisting}

The second line spawns two copies of (* 3 4) and performs redundant work, while Haskell's version does not. The Upside is that Scheme's macro system offers other flexibilities not shown in this lecture.

\subsubsection{Dynamic and Static Typing}

In Scheme:
\begin{lstlisting}
    (if #f 0 (+ 0 "hello"))
    (if #t 0 (+ 0 "hello"))
\end{lstlisting}

The first line fails but the second line succeeds. This is because Types are checked dynamically. When running the program, only the code that is actually run is checked.

In Haskell, the following line fails:
\begin{lstlisting}
    if True then 0 else 0 + "hello"
\end{lstlisting}

The reason for this is because types are checked statically, without running, over all the code. (If this code is compiled, then at compile time, if interpreted, then at load time, etc.) So the error of adding 0 to "hello".\\
\\
Food for though, Java is both compiled and interpreted.

\subsubsection{Parametric Polymorphism}

In Haskell, we define:

\begin{lstlisting}
    trio x = [x, x, x]
\end{lstlisting}
The inferred type is:
\begin{lstlisting}
    a -> [a]
\end{lstlisting}
This is analogous to Java's 
\begin{lstlisting}
    <T> LinkedList<T> trio(<T> x)
\end{lstlisting}

\underline{Note:} That the following 2 lines are both legal if we have trio defined
\begin{lstlisting}
    trio 0
    trio "hello"
\end{lstlisting}

"Parametric" means:
Supposed you have defined $d$ of type $a \mapsto [a]$, Then you would need one test to know what it does. Say we test $d True$ and the answer has length 2. Then we can deduce that $d x$ returns $[x,x]$ for all $x$.\\
\\
The basic explanation for this is that $d$ cannot vary behaviour by types. Haskell allows type-determined behaviour, but the function type will look like:
\begin{lstlisting}
    Foo a => a -> [a]
\end{lstlisting}

\subsubsection{What is "Powerful"? -- The Tradeoff}

"Macro systems, dynamic typing, ... are powerful." This refers to the flexibility for the implementer or the original author.\\
\\
"Static typing, parametric polymorphism... are powerful." This refers to the predictability for the user or the maintainer.\\
\\
Programming is a dialectic class struggle between the user and the implementer. Or between the maintainer and the original author.

\newpage

\section{Thursday, January 18, 2018}

\subsection{Racket}

We won't be using just Scheme, we'll be using Racket which is a version of Scheme. Racket is a platform for implementing and using many languages, and Scheme is on of those that come out of the box.\\
\\
Racket's version of scheme is somewhat different from the standards with regards to function names, and some features. We will cover Racket, but note that these examples and features may fail for standard Scheme.

\subsection{Basic Data Types}

\begin{lstlisting}
    #t, #f ;booleans
    42 ;numbers, can be ints, rational, floats, complex
    "hello" ; strings
    #\h ; this is a char of just the letter h
    'Chrome ;this is a symbol
\end{lstlisting}

\paragraph{Symbols} Symbols are user-defined atomic values. You think of a name, put a single quote in front. Symbols are not strings, you can't perform string operations onto them.

\subsection{Procedures and Functions}
For example:
\begin{lstlisting}
    (sin (/ 0.2 2)) ; sine of 1 over 10
\end{lstlisting}

\subsection{Boolean Operations}

\begin{lstlisting}
    (not expr)
    (and expr expr)
    (or expr expr)
    (or) ; gives #f
    (and) ; gives #t
    (boolean? expr) ; tests if you have a boolean
\end{lstlisting}

\subsection{Number operations}

\begin{lstlisting}
    +
    -
    *
    /
    max
    min
    -
    <
    >
    <=
    >=
    ; these operations can all take multiple operands
\end{lstlisting}

\begin{lstlisting}
    number?
    complex?
    real?
    rational?
    ; these functions test if a number is a certain type
\end{lstlisting}

\subsection{Equality}

There are 3 types of equalities.

\begin{lstlisting}
    eq?
\end{lstlisting}
	This one is Good for booleans and symbols, uses pointer inequality for aggregates like strings and lists, but has complicated rules for numbers.
	
\begin{lstlisting}
    eqv?
\end{lstlisting}
	This one has complicated rules for numbers as well, and different from eq? as it treats the floating-points NaN and signed zero differently.
	
	\begin{lstlisting}
    equal?
\end{lstlisting}
This one is for structural equality for most aggregates. So comparing contents of an aggregate.

\subsection{Definitions}

You can define functions and constants, recursion is allowed.

\begin{lstlisting}
; A constant
(define my-width/height (/ 4 3))
; a function with 2 parameters
(define (my-log base x)
	(/ (log x) (log base)))
    
\end{lstlisting}

\subsection{Anonymous Functions}

Basically a function without a name, you can either right lambda or use $\lambda$ in your code.\\
\\
Example of a function:
\begin{lstlisting}
    (lambda (base x) (/ (log x) (log base)))
\end{lstlisting}
Example of the same function being used
\begin{lstlisting}
    ((lambda (base x) (/ (log x) (log base))) 128 2)
\end{lstlisting}
So in this case, base passed in as 128 and x as 2

\subsection{Conditionals}

If-then-else conditions look like the following
\begin{lstlisting}
	(if test then-expr else-expr)
\end{lstlisting}
Test can be non-boolean, and this will be treated as true.

Multiple conditions are as such:
\begin{lstlisting}
	(cond
		[(> x y) (sin x)]
		[(< x y) (cos y)]
		[else 0])
\end{lstlisting}
This is if $x>y$ then $sinx$ else if $x < y$ then $cosy$ else 0. Test results can be non-boolean, which are treated as true. You can obtain the result of a test to return it.
\begin{lstlisting}
	(cond
		[(+ 4 2) => (lambda (x) (* x x))]
		[else 0])
\end{lstlisting}
This gives 36.

\subsubsection{and,or as conditionals}
\textbf{and} evaluates all of its operands from left to right and stops as soon as \#f operand is read, otherwise the last expression is the answer.\\
\\
\textbf{or} evaluates all of its operands from left to right and stops as soon as a non \#f operand is read, and that becomes the answer, otherwise the answer is \# f

\subsection{Local bindings}

Local definitions for use in just one expression

\begin{lstlisting}
	(let ([x expr1]
		[y expr2])
		(+ x y (* 2 x y)))
\end{lstlisting}
This means to compute $x+y+2xy$ where $x=expr1$ and $y=expr2$. These 2 expressions cannot see the others variables, only the global ones outside of their scope.
\begin{lstlisting}
	(let ([x 3])
		(let ([x (* 3 3)]) ; (* 3 3)
		x))
\end{lstlisting}
This results in 9 and is not recursive. Let* allows later bindings to see earlier bindings
\begin{lstlisting}
	(let* ([x 5]
		[y (+ x 1)]) ; (+ 5 1)
		(+ x y (* 2 x y)))
\end{lstlisting}
\subsubsection{Recursive local bindings}

letrec allows more recursive bindings

\begin{lstlisting}
	(letrec ([fac
		(lambda (n)
			(if (= n 0) 1 (* n (fac (- n 1)))))]
		[even
			(lambda (n)
				(or (= n 0) (not (odd (- n 1)))))]
		[odd
			(lambda (n)
				(not (even (- n 1))))])
	(even (fac 5))) 
\end{lstlisting}
This returns whether or not factorial 5 is even. So true.

\subsection{Recommended Code Layout}

\begin{itemize}
	\item{Open parentheses then immediately first word}
	\item{Procedure definition: Body starts on new line, indented}
	\item{Long expression: Parts start on new lines, indented}
	\item{Closing parentheses not on new lines}
\end{itemize}

\newpage

\section{Thursday, January 25, 2018}

\subsection{Pairs and Lists}

A cons cell is a 2-tuple pair and has the following syntax:
\begin{lstlisting}
	cons(x y)
\end{lstlisting}
Essentially a pair of pointers. Has special support for lists.
\begin{lstlisting}
	'() ; an empty list
	(list x y z) = (cons x (cons y (cons z '())))
	'(42 "hi" Chrome)
	; Chrome here will be the symbol 'Chrome
\end{lstlisting}

For a cons cell, you can use car to access the first field and cdr to access the second field.

\subsection{User-Defined Records}

\begin{lstlisting}
	(struct dim (width height))
\end{lstlisting}
This creates a new record type with 2 fields
\begin{lstlisting}
	(dim 4 7) ; this constructs a vlue of this type
	dim? ; this tests for this type
	dim-width
	dim-height
	; these are the field accessors
\end{lstlisting}

We can also use struct-copy to clone a record while replacing some values:
\begin{lstlisting}
	(define d1 (dim 4 7))
	(define d2 (struct-copy dim d1 [width 5]))
	; d2 is (dim 5 7)
\end{lstlisting}

\subsection{Pattern Matching}

You can test for a literal, cons cell, or a record type, can get their content as well.

\begin{lstlisting}
	(struct dim (width height))
	
	(define (foo x)
		(match x
			['() 'nada]
			[(cons b _) b]
			[(dim w h) (* w h)]))
	(foo '()) ; returns 'nada
	(foo '(1 2 3)) ; returns 1
	(foo (dim 4 7)) ; returns 28
\end{lstlisting}

\subsection{Input and Output}

We can print with display, printf and displayln

\begin{lstlisting}
	(display 5)
	(newline)
	(displayln 5)
	(printf "yes" "price" 5)
\end{lstlisting}

\begin{lstlisting}
	(read-line) ; this reads a lien
	(read-string 10) ; this reads up to the upper bound.
	;if it reaches the end of the file, it returns eof, which you can use eq? or eof-object? to test
	; for stderr, eprintf is like printf but goes to stderr
\end{lstlisting}

\subsubsection{ports}

Racket has ports, analogous to Java Reader/Writer -- behind it can be file, string, network connection, message queue, user-defined, etc.

\subsection{Sequencing}

If we want to evaluate multiple expressions in the order we specify

\begin{lstlisting}
	(begin
		(display ln "Please enter your name")
		(read-line)) ; this returns the last expression
		
	(begin0 expr1 expr2) ; this returns the first expression, but the others are still evaluated.
	
	(when (> x 0) expr1 expr2 ...)
	; if true, evaluates the exoressions, returns what the last one returns, if false, returns #<void>
\end{lstlisting}

\subsection{Mutable Varibles}

\begin{lstlisting}
	(define v 5)
	(define (f x) (+ x v))
	(f 0) ; this gives 5
	(set! v 6)
	(f 0) ; this gives 6
\end{lstlisting}

Mutable paris, list, strings, arrays, etc. are also available. Use mutation judiciously, is not that necessary.

\subsection{map}

Takes in a function and a list and applies the function to every element in that list

\begin{lstlisting}
	(map f (list x y z)) = (list (f x) (f y) (f z))
\end{lstlisting}

\subsection{filter}

filter takes in a boolean function and a list (A) and returns a list of the items in the list A that satisfy the boolean function

\begin{lstlisting}
	(filter number? '(9 "4" 0 "1" "6" 5)) = '(9 0 5)
\end{lstlisting}


\newpage

\section{Thursday, February 1, 2018}

\subsection{Scheme (cont'd)}

\subsubsection{foldl}

Consider the problem of summing an entire list and multiplying an entire list. Summing requires us to add up all the elements of the list plus 0 for the first item. Multiplying requires us to multiply up all the elements of the list times 1 for the first item. This is the motivation.\\
\\
So we define foldl as

\begin{lstlisting}
    (define (foldl binop a lst)
	(match lst
	[?() a]
	[( cons hd tl) (foldl binop (binop a hd) tl )]))
\end{lstlisting}

So Intuitively, 

\begin{lstlisting}
	(foldl binop a (list x y z))
\end{lstlisting}

Looks like

$$(((a + x) + y) + z)$$

where $+$ is where binop is being performed

\subsubsection{foldr}

Basically in the opposite direction of foldl, so if

\begin{lstlisting}
	(foldl binop a (list x y z))
\end{lstlisting}

Looks like

$$(z + (y + (x+a)))$$

where $+$ is where binop is being performed, then

\begin{lstlisting}
	(foldr binop a (list x y z))
\end{lstlisting}

Looks like

$$(((a + x) + y) + z)$$

where $+$ is where binop is being performed, then

\subsubsection{Procedure-Call Stack}

Consider the following:

\begin{lstlisting}
	(define (f n) (... (f (- n 1)) ...)
	(displayln (+ (f 4) (f 1) (f 6)))
\end{lstlisting}

The Control-flow jumps to into $f$ when it's called and later knows where to return to after the recursive calls. This is done because a stack is used to remember where to return to in recursion, called a \textbf{Call Stack}. The Benefit of this is that it supports recursion, but it comes at a price of occupying $\theta (1)$ space while the stack is being used.

\subsubsection{Non-Tail Calls and Tail Calls}

\textbf{Non-Tail Calls}, are if you still have to do your own processing or computation after getting the results from another function, so basically the results are not returned right away.
\\
\\
For example, for the following function:

\begin{lstlisting}
	(define (my -sum lst)
		(match lst [?() 0]
				[( cons hd tl) (+ hd (my -sum tl ))]))
\end{lstlisting}

Takes $\theta (n)$ space if the list length is $n$.\\
\\
A Tail call is the exact opposite, there is no computation after getting the results back from a called function and the function returns the value right away. The complexity of this is $O(1)$ under Tail-Calling optimization in Scheme.\\
\\
Tail-Calling optimization isn't in every language, Java and Python don't have this.

\subsection{Haskell}

\subsubsection{Expressions and Types}

\paragraph{Characters} chars are denoted with single quotes

\paragraph{Tuples} Not the same as cons

\paragraph{()} is a special time, called the unit type, used as a return value for functions that don't return anything

\paragraph{Lists} Lists are implemented as such:

\begin{lstlisting}
	3 : ( 1 : (4 : [])) = [3,1,4]
\end{lstlisting}

So a list of length one is an item with an empty list and the colon inbetween separates the items
\begin{lstlisting}
	[1] = 1 : []
\end{lstlisting}

Note that the following list has a type $[[integer]]$

\begin{lstlisting}
	[[3,1,4], [10,20], []]
\end{lstlisting}

So as for now, arbitrary list nesting is not supported, so basically

\begin{lstlisting}
	[1, [3]]
\end{lstlisting}

is not supported (yet).

Note that because of static typing, every item must be the same type, we can't mix integers with floats in the same list.

\paragraph{Strings} are a list of chars. The downside of this is that it uses a huge amount of memory, as it's stored as a linked list, and each node and pointer takes up a linear amount of space.

\paragraph{Keyword: Just} If you type

\begin{lstlisting}
	Just 'C'
\end{lstlisting}

The variable is either Nothing or Char

\paragraph{Nothing} Is the empty type, can be any type

\paragraph{"Left 'C'"} Can either be of type Char Bool, Char Int,  ... all we know that the left variable is a character.

\paragraph{"Right False"} Can either be of type Char bool, Int bool, ... all we know that the right variable is a boolean

\paragraph{anonymous functions} Ex.

\begin{lstlisting}
	 \x -> x >= 'C'
\end{lstlisting}

Has the type Char -$>$ Bool with char as the domain and bool as the codomain

\subsubsection{Definitions}

We can define expressions to variables and vice versa, for example, in the following, we are defining "ten" to be "$1+2+3+4$" and binding "$1+2+3+4$" to "ten":
\begin{lstlisting}
	ten = 1 + 2 + 3 + 4
\end{lstlisting}

There is also pattern binding, with tuples, but that will be shown later\\
\\
Functions can also be defined:

\begin{lstlisting}
	square x = x * x
	nand a b =  not (a && b)
\end{lstlisting}

We can also define type signatures for the definitions as such

\begin{lstlisting}
	ten, four :: Integer
\end{lstlisting}

But Haskell is written such that the type signature can be separated from the definition, so you don't have to put them in the same few lines, they just have to be in the same file.

\subsubsection{Function Applications}

If you insert one parameter to a function that takes 2 parameters, that function will return a function of 1 parameter. This is how Haskell does multiple parameters

\newpage

\section{Thursday, February 8, 2018}

\subsection{Haskell (cont'd)}

\subsubsection{Local Definitions For Expressions}

\begin{lstlisting}
	let x = 4 + 5
	     y = 4 - 5
	 in x+y+2*x*y
\end{lstlisting}

Layout Version above. Braced Version below

\subsubsection{Local Definitions For Definitions}

\begin{lstlisting}
	for u v = x + y + 2*x*y
		where
			x = u + v
			y= u - v
\end{lstlisting}

\end{document}


























