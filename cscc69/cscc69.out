\BOOKMARK [1][-]{section.1}{Tuesday, May 8, 2018}{}% 1
\BOOKMARK [2][-]{subsection.1.1}{What is an operating system?}{section.1}% 2
\BOOKMARK [2][-]{subsection.1.2}{Storage Hierarchy}{section.1}% 3
\BOOKMARK [2][-]{subsection.1.3}{Storage Structure}{section.1}% 4
\BOOKMARK [2][-]{subsection.1.4}{Caching}{section.1}% 5
\BOOKMARK [2][-]{subsection.1.5}{Concurrency}{section.1}% 6
\BOOKMARK [2][-]{subsection.1.6}{C Programming and Memory}{section.1}% 7
\BOOKMARK [2][-]{subsection.1.7}{The Process Concept}{section.1}% 8
\BOOKMARK [2][-]{subsection.1.8}{Process Data Structures}{section.1}% 9
\BOOKMARK [2][-]{subsection.1.9}{Process Control Block}{section.1}% 10
\BOOKMARK [2][-]{subsection.1.10}{Process state and state changes}{section.1}% 11
\BOOKMARK [2][-]{subsection.1.11}{State Queues}{section.1}% 12
\BOOKMARK [2][-]{subsection.1.12}{PCBs and State Queues}{section.1}% 13
\BOOKMARK [2][-]{subsection.1.13}{Context Switch}{section.1}% 14
\BOOKMARK [2][-]{subsection.1.14}{Operations on Processes}{section.1}% 15
\BOOKMARK [3][-]{subsubsection.1.14.1}{Process Creation}{subsection.1.14}% 16
\BOOKMARK [3][-]{subsubsection.1.14.2}{Process Termination}{subsection.1.14}% 17
\BOOKMARK [2][-]{subsection.1.15}{Process Creation}{section.1}% 18
\BOOKMARK [3][-]{subsubsection.1.15.1}{Unix}{subsection.1.15}% 19
\BOOKMARK [3][-]{subsubsection.1.15.2}{Why fork?}{subsection.1.15}% 20
\BOOKMARK [3][-]{subsubsection.1.15.3}{Unix Shells}{subsection.1.15}% 21
\BOOKMARK [2][-]{subsection.1.16}{Example: Concurrent Web Server}{section.1}% 22
\BOOKMARK [2][-]{subsection.1.17}{Parallel Programming}{section.1}% 23
\BOOKMARK [2][-]{subsection.1.18}{Example: Concurrent Servers}{section.1}% 24
\BOOKMARK [2][-]{subsection.1.19}{Rethinking Processes}{section.1}% 25
\BOOKMARK [2][-]{subsection.1.20}{Threads}{section.1}% 26
\BOOKMARK [2][-]{subsection.1.21}{Thread Interface}{section.1}% 27
\BOOKMARK [2][-]{subsection.1.22}{Thread Scheduling}{section.1}% 28
\BOOKMARK [2][-]{subsection.1.23}{Threads Summary}{section.1}% 29
\BOOKMARK [2][-]{subsection.1.24}{Cooperating Processes}{section.1}% 30
\BOOKMARK [2][-]{subsection.1.25}{Interprocess Communication}{section.1}% 31
\BOOKMARK [1][-]{section.2}{Tuesday, May 15, 2018}{}% 32
\BOOKMARK [2][-]{subsection.2.1}{Bootstrapping}{section.2}% 33
\BOOKMARK [2][-]{subsection.2.2}{Operating System Startup}{section.2}% 34
\BOOKMARK [2][-]{subsection.2.3}{Memory Layout}{section.2}% 35
\BOOKMARK [2][-]{subsection.2.4}{From Program to Process}{section.2}% 36
\BOOKMARK [2][-]{subsection.2.5}{Unix Shells}{section.2}% 37
\BOOKMARK [2][-]{subsection.2.6}{Requesting OS Services}{section.2}% 38
\BOOKMARK [2][-]{subsection.2.7}{Boundary Crossings}{section.2}% 39
\BOOKMARK [2][-]{subsection.2.8}{System Calls for Process Management}{section.2}% 40
\BOOKMARK [2][-]{subsection.2.9}{System Calls for File Manamgement}{section.2}% 41
\BOOKMARK [2][-]{subsection.2.10}{Systems Call Example}{section.2}% 42
\BOOKMARK [2][-]{subsection.2.11}{System Call Interface}{section.2}% 43
\BOOKMARK [2][-]{subsection.2.12}{System Call Operation}{section.2}% 44
\BOOKMARK [2][-]{subsection.2.13}{Introduction to Synchronization}{section.2}% 45
\BOOKMARK [3][-]{subsubsection.2.13.1}{Motivating Example}{subsection.2.13}% 46
\BOOKMARK [3][-]{subsubsection.2.13.2}{Interlevced Schedules}{subsection.2.13}% 47
\BOOKMARK [3][-]{subsubsection.2.13.3}{What went wrong}{subsection.2.13}% 48
\BOOKMARK [3][-]{subsubsection.2.13.4}{Revisiting the Example}{subsection.2.13}% 49
\BOOKMARK [3][-]{subsubsection.2.13.5}{Mutal Exclusion}{subsection.2.13}% 50
\BOOKMARK [3][-]{subsubsection.2.13.6}{What program data is shared between threads?}{subsection.2.13}% 51
\BOOKMARK [3][-]{subsubsection.2.13.7}{The Critical Section Problem}{subsection.2.13}% 52
\BOOKMARK [3][-]{subsubsection.2.13.8}{Critical Section Requirements}{subsection.2.13}% 53
\BOOKMARK [3][-]{subsubsection.2.13.9}{Some Assumptions and Notation}{subsection.2.13}% 54
\BOOKMARK [3][-]{subsubsection.2.13.10}{2-Thread Solutions: First Attempt}{subsection.2.13}% 55
\BOOKMARK [3][-]{subsubsection.2.13.11}{2-Thread Solutions: Second Attempt}{subsection.2.13}% 56
\BOOKMARK [3][-]{subsubsection.2.13.12}{2-Thread Solutions: Third Attempt}{subsection.2.13}% 57
\BOOKMARK [3][-]{subsubsection.2.13.13}{Synchronization Hardware}{subsection.2.13}% 58
\BOOKMARK [3][-]{subsubsection.2.13.14}{Atomic Instructions: Test-and-Set Lock \(TSL\)}{subsection.2.13}% 59
\BOOKMARK [1][-]{section.3}{Tuesday, May 22, 2018}{}% 60
\BOOKMARK [2][-]{subsection.3.1}{Producer and Consumer}{section.3}% 61
\BOOKMARK [2][-]{subsection.3.2}{Semaphores}{section.3}% 62
\BOOKMARK [3][-]{subsubsection.3.2.1}{Types of Semaphores}{subsection.3.2}% 63
\BOOKMARK [2][-]{subsection.3.3}{The reader, writer problem}{section.3}% 64
\BOOKMARK [2][-]{subsection.3.4}{Monitors}{section.3}% 65
\BOOKMARK [3][-]{subsubsection.3.4.1}{Bounded Buffer Problem}{subsection.3.4}% 66
\BOOKMARK [2][-]{subsection.3.5}{Process Scheduling}{section.3}% 67
\BOOKMARK [3][-]{subsubsection.3.5.1}{What happens on a dispatch /context switch?}{subsection.3.5}% 68
\BOOKMARK [3][-]{subsubsection.3.5.2}{Process Life Cycle}{subsection.3.5}% 69
\BOOKMARK [3][-]{subsubsection.3.5.3}{What is processor scheduling?}{subsection.3.5}% 70
\BOOKMARK [3][-]{subsubsection.3.5.4}{Scheduling Goals}{subsection.3.5}% 71
\BOOKMARK [3][-]{subsubsection.3.5.5}{Types of Scheduling}{subsection.3.5}% 72
\BOOKMARK [1][-]{section.4}{Tuesday, May 29, 2018}{}% 73
\BOOKMARK [2][-]{subsection.4.1}{Problem: Dining Philosophers}{section.4}% 74
\BOOKMARK [2][-]{subsection.4.2}{Scheduling Algorithms}{section.4}% 75
\BOOKMARK [3][-]{subsubsection.4.2.1}{FCFS}{subsection.4.2}% 76
\BOOKMARK [3][-]{subsubsection.4.2.2}{SJF}{subsection.4.2}% 77
\BOOKMARK [3][-]{subsubsection.4.2.3}{Round Robin}{subsection.4.2}% 78
\BOOKMARK [3][-]{subsubsection.4.2.4}{Mars Rover Pathfinder Bug Example}{subsection.4.2}% 79
\BOOKMARK [2][-]{subsection.4.3}{What do real systems do?}{section.4}% 80
\BOOKMARK [3][-]{subsubsection.4.3.1}{Multi-Level Queue Scheduling}{subsection.4.3}% 81
\BOOKMARK [3][-]{subsubsection.4.3.2}{Feedback Scheduling}{subsection.4.3}% 82
\BOOKMARK [3][-]{subsubsection.4.3.3}{Timesharing in Linux 2.8}{subsection.4.3}% 83
\BOOKMARK [1][-]{section.5}{Tuesday, June 5, 2018}{}% 84
\BOOKMARK [2][-]{subsection.5.1}{Memory Management}{section.5}% 85
\BOOKMARK [3][-]{subsubsection.5.1.1}{Requirements}{subsection.5.1}% 86
\BOOKMARK [3][-]{subsubsection.5.1.2}{Meeting the Requirements}{subsection.5.1}% 87
\BOOKMARK [3][-]{subsubsection.5.1.3}{Address Binding}{subsection.5.1}% 88
\BOOKMARK [3][-]{subsubsection.5.1.4}{When are addresses bound?}{subsection.5.1}% 89
\BOOKMARK [3][-]{subsubsection.5.1.5}{Address Translation: Logical and physical addresses}{subsection.5.1}% 90
\BOOKMARK [3][-]{subsubsection.5.1.6}{Fixed Partitioning}{subsection.5.1}% 91
\BOOKMARK [3][-]{subsubsection.5.1.7}{Dynamic Partitioning}{subsection.5.1}% 92
\BOOKMARK [3][-]{subsubsection.5.1.8}{Heap Manamgement}{subsection.5.1}% 93
\BOOKMARK [3][-]{subsubsection.5.1.9}{Tracking Memory Allocation}{subsection.5.1}% 94
\BOOKMARK [3][-]{subsubsection.5.1.10}{Placement Algorithms}{subsection.5.1}% 95
\BOOKMARK [3][-]{subsubsection.5.1.11}{Problems with Partitioning}{subsection.5.1}% 96
\BOOKMARK [3][-]{subsubsection.5.1.12}{Paging}{subsection.5.1}% 97
\BOOKMARK [3][-]{subsubsection.5.1.13}{Address Translation}{subsection.5.1}% 98
\BOOKMARK [3][-]{subsubsection.5.1.14}{Address Translation for Paging}{subsection.5.1}% 99
\BOOKMARK [3][-]{subsubsection.5.1.15}{Page Table Entries \(PTE\)}{subsection.5.1}% 100
\BOOKMARK [3][-]{subsubsection.5.1.16}{Page Lookups}{subsection.5.1}% 101
\BOOKMARK [3][-]{subsubsection.5.1.17}{Translation Lookaside Buffer}{subsection.5.1}% 102
\BOOKMARK [3][-]{subsubsection.5.1.18}{Managing TLBs}{subsection.5.1}% 103
